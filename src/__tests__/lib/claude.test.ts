import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { join } from "node:path";
import { existsSync, mkdirSync, readFileSync, symlinkSync, writeFileSync, rmSync } from "node:fs";
import { createTestDir, createTestGitRepo, cleanup, GIT_ENV } from "../helpers";
import { createPaths } from "../../constants";
import { writeConfig } from "../../lib/config";
import { generateClaudeFiles } from "../../lib/claude";

describe("generateClaudeFiles", () => {
  let tempDir: string;
  let paths: ReturnType<typeof createPaths>;

  beforeEach(() => {
    tempDir = createTestDir();
    paths = createPaths(join(tempDir, "workspaces"));
  });

  afterEach(() => {
    cleanup(tempDir);
  });

  /** Create workspace dir, .claude dir, and workspace.json */
  function setupWorkspace(ws: string, repos: { name: string; path: string }[] = []) {
    mkdirSync(paths.workspace(ws), { recursive: true });
    mkdirSync(paths.workspaceDotClaude(ws), { recursive: true });
    writeConfig(paths.workspaceConfig(ws), { name: ws, repos });
  }

  /**
   * Create a real git repo, wire up trees/{repo}/{slug} symlink,
   * and optionally write a CLAUDE.md into the repo.
   */
  function setupRepo(
    ws: string,
    name: string,
    opts: { defaultBranch?: string; hasClaude?: boolean } = {},
  ): string {
    const { defaultBranch = "main", hasClaude = true } = opts;
    const repoPath = createTestGitRepo(tempDir, name, defaultBranch);

    // Create trees/{repo}/ dir and symlink trees/{repo}/{slug} -> repo
    const repoDir = paths.repoDir(ws, name);
    mkdirSync(repoDir, { recursive: true });
    const slug = defaultBranch.replaceAll("/", "-");
    symlinkSync(repoPath, paths.worktreeDir(ws, name, slug));

    if (hasClaude) {
      writeFileSync(join(repoPath, "CLAUDE.md"), `# ${name}\nProject docs.\n`);
    }

    return repoPath;
  }

  // ── trees.md generation ─────────────────────────────────────────

  describe("trees.md generation", () => {
    it("generates trees.md with @references for repos that have CLAUDE.md", () => {
      const pathA = setupRepo("ws", "alpha");
      const pathB = setupRepo("ws", "bravo");
      setupWorkspace("ws", [
        { name: "alpha", path: pathA },
        { name: "bravo", path: pathB },
      ]);

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.treesMd).toEqual(["alpha", "bravo"]);

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      expect(content).toContain("@../trees/alpha/main/CLAUDE.md");
      expect(content).toContain("@../trees/bravo/main/CLAUDE.md");
    });

    it("skips repos whose worktree has no CLAUDE.md", () => {
      const pathA = setupRepo("ws", "alpha", { hasClaude: true });
      const pathB = setupRepo("ws", "bravo", { hasClaude: false });
      setupWorkspace("ws", [
        { name: "alpha", path: pathA },
        { name: "bravo", path: pathB },
      ]);

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.treesMd).toEqual(["alpha"]);

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      expect(content).toContain("@../trees/alpha/main/CLAUDE.md");
      expect(content).not.toContain("bravo");
    });

    it("generates trees.md with header but no @references when no repos have CLAUDE.md", () => {
      const pathA = setupRepo("ws", "alpha", { hasClaude: false });
      setupWorkspace("ws", [{ name: "alpha", path: pathA }]);

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.treesMd).toEqual([]);

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      expect(content).not.toContain("@");
      expect(content).toContain("Generated by dotclaude");
    });

    it("sorts references alphabetically by repo name", () => {
      const pathZ = setupRepo("ws", "zebra");
      const pathA = setupRepo("ws", "apple");
      const pathM = setupRepo("ws", "mango");
      setupWorkspace("ws", [
        { name: "zebra", path: pathZ },
        { name: "apple", path: pathA },
        { name: "mango", path: pathM },
      ]);

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.treesMd).toEqual(["apple", "mango", "zebra"]);

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      const lines = content.split("\n").filter((l) => l.startsWith("@"));
      expect(lines[0]).toContain("apple");
      expect(lines[1]).toContain("mango");
      expect(lines[2]).toContain("zebra");
    });

    it("uses slugified branch in path", () => {
      const pathA = setupRepo("ws", "alpha", { defaultBranch: "release/1.0" });
      setupWorkspace("ws", [{ name: "alpha", path: pathA }]);

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      expect(content).toContain("@../trees/alpha/release-1.0/CLAUDE.md");
    });

    it("handles multi-level branch slugification", () => {
      const pathA = setupRepo("ws", "alpha", { defaultBranch: "feature/team/task-123" });
      setupWorkspace("ws", [{ name: "alpha", path: pathA }]);

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      expect(content).toContain("@../trees/alpha/feature-team-task-123/CLAUDE.md");
    });

    it("generates trees.md for empty workspace", () => {
      setupWorkspace("ws");

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.treesMd).toEqual([]);
      expect(existsSync(paths.claudeTreesMd("ws"))).toBe(true);

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      expect(content).toContain("Generated by dotclaude");
    });

    it("overwrites existing trees.md on regeneration", () => {
      const pathA = setupRepo("ws", "alpha");
      setupWorkspace("ws", [{ name: "alpha", path: pathA }]);

      writeFileSync(paths.claudeTreesMd("ws"), "stale content\n");

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      expect(content).not.toContain("stale content");
      expect(content).toContain("@../trees/alpha/main/CLAUDE.md");
    });

    it("emits each @reference on its own line", () => {
      const pathA = setupRepo("ws", "alpha");
      const pathB = setupRepo("ws", "bravo");
      setupWorkspace("ws", [
        { name: "alpha", path: pathA },
        { name: "bravo", path: pathB },
      ]);

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);

      const content = readFileSync(paths.claudeTreesMd("ws"), "utf-8");
      const atLines = content.split("\n").filter((l) => l.startsWith("@"));
      expect(atLines).toHaveLength(2);
      expect(atLines[0]).toBe("@../trees/alpha/main/CLAUDE.md");
      expect(atLines[1]).toBe("@../trees/bravo/main/CLAUDE.md");
    });
  });

  // ── CLAUDE.md creation ──────────────────────────────────────────

  describe("CLAUDE.md creation", () => {
    it("creates CLAUDE.md when it does not exist", () => {
      setupWorkspace("ws");

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.claudeMd).toBe("created");

      const content = readFileSync(paths.claudeMd("ws"), "utf-8");
      expect(content).toContain("@.claude/trees.md");
    });

    it("does not overwrite existing CLAUDE.md", () => {
      setupWorkspace("ws");
      writeFileSync(paths.claudeMd("ws"), "# My custom workspace notes\n@.claude/trees.md\n");

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.claudeMd).toBe("exists");

      const content = readFileSync(paths.claudeMd("ws"), "utf-8");
      expect(content).toBe("# My custom workspace notes\n@.claude/trees.md\n");
    });

    it("is idempotent across both files", () => {
      const pathA = setupRepo("ws", "alpha");
      setupWorkspace("ws", [{ name: "alpha", path: pathA }]);

      const result1 = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result1.ok).toBe(true);
      const claudeMd1 = readFileSync(paths.claudeMd("ws"), "utf-8");
      const treesMd1 = readFileSync(paths.claudeTreesMd("ws"), "utf-8");

      const result2 = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result2.ok).toBe(true);
      const claudeMd2 = readFileSync(paths.claudeMd("ws"), "utf-8");
      const treesMd2 = readFileSync(paths.claudeTreesMd("ws"), "utf-8");

      expect(claudeMd1).toBe(claudeMd2);
      expect(treesMd1).toBe(treesMd2);
    });
  });

  // ── error handling ──────────────────────────────────────────────

  describe("error handling", () => {
    it("returns WORKSPACE_NOT_FOUND for non-existent workspace", () => {
      const result = generateClaudeFiles("ghost", paths, GIT_ENV);
      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.code).toBe("WORKSPACE_NOT_FOUND");
      }
    });

    it("skips repos with dangling source path", () => {
      const pathA = setupRepo("ws", "alpha");
      const pathB = setupRepo("ws", "bravo");
      setupWorkspace("ws", [
        { name: "alpha", path: pathA },
        { name: "bravo", path: pathB },
      ]);

      // Delete bravo's source repo
      rmSync(pathB, { recursive: true, force: true });

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.treesMd).toEqual(["alpha"]);
    });

    it("skips repos where getDefaultBranch fails", () => {
      const pathA = setupRepo("ws", "alpha");

      // Create a repo with detached HEAD using the .git/HEAD write pattern
      const detachedPath = join(tempDir, "bravo");
      mkdirSync(detachedPath, { recursive: true });
      const gitEnv = {
        ...process.env,
        ...GIT_ENV,
        HOME: tempDir,
      };
      Bun.spawnSync(["git", "init", "-b", "main", detachedPath], { env: gitEnv });
      Bun.spawnSync(["git", "-C", detachedPath, "config", "user.email", "test@test.com"], {
        env: gitEnv,
      });
      Bun.spawnSync(["git", "-C", detachedPath, "config", "user.name", "Test"], { env: gitEnv });
      writeFileSync(join(detachedPath, "README"), "x");
      Bun.spawnSync(["git", "-C", detachedPath, "add", "."], { env: gitEnv });
      Bun.spawnSync(["git", "-C", detachedPath, "commit", "-m", "init"], { env: gitEnv });
      const shaResult = Bun.spawnSync(["git", "-C", detachedPath, "rev-parse", "HEAD"], {
        env: gitEnv,
      });
      const sha = new TextDecoder().decode(shaResult.stdout).trim();
      writeFileSync(join(detachedPath, ".git", "HEAD"), sha + "\n");

      writeFileSync(join(detachedPath, "CLAUDE.md"), "# bravo\n");

      // Set up tree dir but no slug symlink (can't determine branch)
      mkdirSync(paths.repoDir("ws", "bravo"), { recursive: true });

      setupWorkspace("ws", [
        { name: "alpha", path: pathA },
        { name: "bravo", path: detachedPath },
      ]);

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value.treesMd).toEqual(["alpha"]);
    });

    it("creates .claude directory if missing", () => {
      setupWorkspace("ws");
      // Remove the .claude/ dir that setupWorkspace created
      rmSync(paths.workspaceDotClaude("ws"), { recursive: true, force: true });

      const result = generateClaudeFiles("ws", paths, GIT_ENV);
      expect(result.ok).toBe(true);
      expect(existsSync(paths.claudeTreesMd("ws"))).toBe(true);
    });
  });
});
